﻿site
http://blog.csdn.net/liuxuezong/article/details/7666153     -- example ,beginer     
http://mryufeng.iteye.com/blog/472840                       -- 实验Erlang语法对应的opcode 让你对erlang理解更深

env distel
http://blog.csdn.net/thomescai/article/details/7461768
http://jixiuf.github.io/erlang/distel.html

1.数字类型，需要注意两点
    1）B#Val表示以B进制存储的数字Val
        2#101               5
    2）$Char表示字符Char的ascii编码
        A                   65
2.atom，可以理解成常量，它可以包含任何字符，以小写字母开头，如果不是以小写字母开头或者是字母之外的符号，需要用单引号包括起来
    abc
    'AB'
3.Tuple
    {1,2,3,4,5}.
    {a,b,c,1,2}.
    size({1,2,3,a,b,c}).
4.list
    [123, xyz].
    [123, def, abc].
    [{person, 'Joe', 'Armstrong'},
        {person, 'Robert', 'Virding'},
        {person, 'Mike', 'Williams'}
    ].
    "abc"                   [97,98,99]
    length([1,2,3]).
6.Erlang中变量有两个特点：
    1）变量必须以大写字母或者下划线开头，可以包含字母、下划线和@
    2）变量只能绑定一次，也就是所谓的Single Assignment。或者以一般的说法就是只能赋值一次，其实Erlang并没有赋值这样的概念,=号也是用于验证匹配。
7.模式匹配——Pattern Matching
    [A,B|C] = [1,2,3,4,5,6,7]
    A               1
    B               2
    C               [3,4,5,6,7]
    -----Succeeds - binds A = 1, B = 2, C = [3,4,5,6,7]
    
    [H|T] = [abc]
    -----Succeeds - binds H = abc, T = []
8.module
    函数定义
    example：
    helloWorld.erl                  
    -module(helloWorld).            -- 模块名称必须与源文件名相同
    -export([run/1]).               -- 函数定义失败时，导出会提示错误,run/1指的是有一个参数的run函数，因为Erlang允许定义同名的有不同参数的多个函数，通过指定/1来说明要导出的是哪个函数
    run(Name)->                     -- 大写开头的是变量Name，调用io模块的format方法输出，~w可以理解成占位符，将被实际Name取代，~n就是换行了。函数定义完了要以句号：“.”结束
        io:format("Hello World ~w~n", [Name]).
    
    执行  cd("E:/erlang").
         c(helloWorld).             -- 编译源代码helloworld.erl
         helloWorld:run(lllll).

9.example
    http://blog.csdn.net/liuxuezong/article/details/7666153         

10.变量必须大写，在函数定义时, 当匿名函数付给变量是也需要首字母大写
    total([{What,N}|T]) -> shop:cost(What) * N + total(T);
    但是只匹配用的，无需大写，例如这里的milk
    cost(milk)-> 7.

11.匿名函数， 使用关键字fun
    Z = fun(X) -> 2 * X end.
    Z(2).
    Double = Z.
    Double(4).
    Double(4,5).
    ** exception error: interpreted function with arity 1 called with two arguments
    d=Z.
    ** exception error: no match of right hand side value #Fun<erl_eval.6.80484245>
    温度转换函数
    TempConvert = fun({c,C}) -> {f, 32 + C*9/5};({f,F}) -> {c, (F-32)*5/9}end.
    #Fun<erl_eval.6.82930912>
    9> TempConvert({c,100}).
    {f,212.0}
    10> TempConvert({f,212}).
    {c,100.0}

12.函数体中定义函数
    outer( C ) –> Inner = fun(A, B) -> A + B + C end,  %% 注意","
    Inner(2, 3). 
13.匿名函数可以当作对象赋给变量，命名函数同样也可以赋给变量。具体用法还是需要借助重要的fun关键字。比如， 
    MyFunction = fun outer / 1 

14.函数的动态调用 
    ErLang有一个apply函数，可以动态调用某一个函数变量。 
    基本用法是 apply( 函数变量，函数参数列表 )。比如，上面的MyFunciton函数变量，就可以这么调用，apply( MyFunction, [ 5 ])。 
    那么我们能否根据一个字符串作为函数名获取一个函数变量呢？这样我们就可以根据一个字符串来动态调用某个函数了。 
    ErLang中，做到这一点很简单。前面讲过，函数名一旦定义了，自然就固定了，这也类似于常量名，属于不可变的atom（原子）。所有的atom都可以转换成字符串，也可以从字符串转换过来。ErLang中的字符串实质上都是List。字符串和atom之间的转换通过list_to_atom和atom_to_list来转换。 
    于是我们可以这样获取MyFunciton：MyFunction = list_to_atom(“outer”) 
    如果outer函数已经定义，那么MyFucntion就等于outer函数，如果outer函数没有定义，那么list_to_atom(“outer”)会产生一个新的叫做outer的atom，MyFucntion就等于这个新产生的atom。 
    如果需要强制产生一个已经存在的atom，那么我们需要调用list_to_existing_atom转换函数，这个函数不会产生新的atom，而是返回一个已经存在了的atom。

15.Tuple和Record
16.循环
    -module(libmisc).
    -export([for/3]).
    for(Max, Max, F) -> [F(Max)];
    for(I, Max, F) -> [F(I)|for(I+1, Max, F)].
    use:
    3> libmisc:for(1,10,fun(I) -> I end).
    [1,2,3,4,5,6,7,8,9,10]
    4> M = fun(I) -> I end.
    5> libmisc:for(1,10,M).             
    [1,2,3,4,5,6,7,8,9,10]
    6> N = fun(I) -> I * I end.
    7> libmisc:for(1,10,N).   
    [1,4,9,16,25,36,49,64,81,100]
    result:
    for(1,10,M)
    => [F(1)| for(2,10,M)]
    => [F(1),F(2)| for(3,10,M)]
    ...
    => [F(1),F(2),F(3),F(4),F(5),F(6),F(7),F(8),F(9),F(10)]
    
17.列表处理
    %%%mylists.erl
    -module(mylists).
    -export([sum/1]).
    sum([H|T]) -> H + sum(T);
    sum([]) -> 0.
    run:
    L = [1,3,10].
    mylists:sum(L).
    
    %%%shop2.erl
    -module(shop2).
    -export([total/1]).
    -import(lists, [map/2]).
    total(L) -> mylists:sum(map(fun({What, N}) -> shop:cost(What) * N end, L)).
    还可以定义成如下格式：
    %%%shop2.erl
    -module(shop2).
    -export([total/1]).
    -import(lists, [map/2, sum/1]).
    -import(shop, [cost/1]).
    total(L) ->sum(map(fun({What, N}) -> cost(What) * N end, L)).
    • The declaration -import(lists, [map/2, sum/1]). means the function map/2 is imported from the module lists, and so on. This means we can write map(Fun, ...) instead of lists:map(Fun, ...). cost/1 was not declared in an import declaration, so we had to use the ―fully qualified‖ name shop:cost.
    • The declaration -export([total/1]) means the function total/1 can be called from outside the module shop2. Only functions that are exported from a module can be called from outside the module.
18.列表分解  可以编写断程序
     L = [1,2,3,4,5].
     lists:map(fun(X) -> 2 * X end, L).         == >> [2*X || X<-L].
     
     Buy=[{oranges,4},{newspaper,1},{apples,10},{pears,6},{milk,3}].
     [{Name, 2*Number} || {Name, Number} <- Buy].

     列出单价和数量
     [(shop:cost(A), B) || {A, B} <- Buy].
     lists:sum([shop:cost(A)*B||{A, B} <-Buy]).   ==> this is shop3
19.area({circle, R}) -> 3.14159*R*R
    大写字母开头代表变量如 R
    小写字母开头代表atom（常量）
    
20.
erlang module的所有BIFs列表见:http://www.erlang.org/doc/man/erlang.html 

21.编译 运行
    .查看/添加代码查找路径 
    code:get_path().  
    code:add_patha(Dir).  
    code:add_pathz(Dir).  
    erl -pa Dir1 -pa Dir2 ... -pz DirK1 -pz DirK2 
    .查看载入的module和查看出错的module 
    code:all_loaded().  
    code:clash().  
    可以将code:add_patha()和code:add_pathz()扔到.erlang文件 
    .运行
    $ erl  
    1> c(hello).  
    2> hello:start().  
    %%%%%%%%%%%%%  
    $ erlc hello.erl  
    $ erl -noshell -s hello start -s init stop  
    %%%%%%%%%%%%%  
    hello.sh
    #!/bin/sh  
    erl -noshell -pa /home/joe/code -s hello start -s init stop  
    %%%%%%%%%%%%%  
    -module(main).  
    -export([main/1]).  
    fac(0) -> 1;  
    fac(N) -> N*fac(N-1).  
    main([A]) ->  
        I = list_to_integer(atom_to_list(A)),  
        F = fac(I),  
        io:format("factorial ~w = ~w~n", [I, F]),  
        init:stop().  
    %%%%%%%%%%%%  
    $ erlc main.erl  
    $ erl -noshell -s main main 25  
    factorial 25 = 15511210043330985984000000  
    
    .使用Makefile构建Erl程序 
    //////////////////////////////////
        % Makefile.template  
        # leave these lines alone  
        .SUFFIXED: .erl .beam .yrl  
          
        .erl.beam:  
          erlc -W $<  
          
        .yrl.erl:  
          erlc -W $<  
          
        ERL = erl -boot start_clean  
          
        # Here's a list of the erlang modules you want compiling  
        # If the modules don't fit onto one line add a \ character  
        # to the end of the lien and continue on the next line  
          
        # Edit the lines below  
        MODS = module1 module2 \  
               module3 ... special1 ...\  
               ...  
               moduleN  
          
        # The first target in any makefile is the default target.  
        # If you just type "make" then "make all" is assumed (because  
        # "all" is the first target in this makefile)  
          
        all: compile  
          
        compile: ${MODS:%=%.beam} subdirs  
          
        ## special compilation requirements are added here  
          
        special1.beam: special1.erl  
          ${ERL} -Dflag1 -WO special1.erl  
          
        ## run an application from the makefile  
          
        application1: compile  
          ${ERL} -pa Dir1 -s application1 start Arg1 Arg2  
          
        # the subdirs target compiles any code in  
        # sub-directories  
          
        subdirs:  
          cd dir1; make  
          cd dir2; make  
          ...  
          
        # remove all the code  
          
        clean:  
          rm -rf *.beam erl_crash.dump  
          cd dir1; make clean  
          cd dir2; make clean 
        /////////////////          
        .Getting Help 
        $ erl -man lists  
        .如果Erlang crash掉了，它会生成一个erl_crash.dump文件，有一个基于Web的crash分析工具 
        webtool:start().  
22.
    erl -sname hideto表示在本地启动一个Erlang节点，名字为hideto 
    如果两个节点在同一机器上，或者没有DNS服务，只能用-sname参数，s表示short 
    不同的机器上使用-name参数来启动节点 
    具体分布式http://hideto.iteye.com/blog/227837
    
23.Record -- http://hideto.iteye.com/blog/241246
    .定义
    -module(my_server).  
    -record(server_opts,  
        {port,  
        ip="127.0.0.1",         %% 默认值
        max_connections=10}).   %% 默认值
    % The rest of your code goes here.  
    .创建
    Opts1 = #server_opts{port=80}.          %% 使用默认值
    Opts2 = #server_opts{port=80, ip="192.168.0.1"}.  
    .访问
    Opts = #server_opts{port=80, ip="192.168.0.1"},  
        内部结构
        {server_opts, 80, "127.0.0.1", 10}  
    .更新Record 
    Opts = #server_opts{port=80, ip="192.168.0.1"},  
    NewOpts = Opts#server_opts{port=7000}.  
    .匹配Record和Guard语句 
        handle(Opts=#server_opts{port=8000}) ->  
        % do special port 8080 stuff  
        handle(Opts=#server_opts{} ->  
        % default stuff  
        ***another example（binding port less 1024 need root right）
        handle(Opts) when Opts#server_opts.port <= 1024 ->  
        % requires root access  
        handle(Opts=#server_opts{}) ->  
        % Doesn't require root access  
        Opts#server_opts.port  
    .如果你想在运行时添加和删除field，或者你在运行时才能确定有哪些field，这时你应该使用dict而不是Record
    
24. Erlang make
    http://hideto.iteye.com/blog/245540
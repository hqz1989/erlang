p23
    C + G, Q, enter   退出
p24 2.2.3 CEAN
    example: http://pragmaticprogrammer.com/titles/jaerlang/code.html
p26 
    推出（linux Ctrl+C/ windows ctrl+break）
    >16#cafe * 32#sugar.        %指定进制的乘法
p32 
    >5 div 3    1
    >5 rem 3    2
    >4/2        2.0000
    atom 常量 小写字母或""
    Preson = {Person,
                {name, joe},
                {height, 1.82}
                {footsize, 42}}.
    {point, x, y} = {point, 10, 20}
    {_, x, y} = {point, 10, 20}
p37
    字符存成ASCII
    f() 释放所有绑定
p43
    erl5.4.12/.erlang 中添加
    io:format("consulting .erlang in ~p~n"), [element(2, file:get_cwd())].
    c:cd("c:/work").
    ......
p49
    Even = fun(X) -> (X rem 2) =:= 0 end.

    返回fun 的fun
    Fruit = [apple, pear, orange]
    MakeTest = fun(L) -> (fun(X) -> lists:member(X,L) end) end.
    IsFruit = MakeTest(Fruit).
    using: 
    IsFruit(pear).     ==> true

    lists:map(fun, L)             ----- 对列表L每个元素实施fun方法，结果形成列表返回
          filter(fun, L)          ----- 对列表L每个元素实施fun方法，将返回true的元素形成列表返回
          member(X, L)            ----- 检验X是否在数组L中
          sum(L)                  ----- 对列表L求和
    lib_misc:for(1,10,fun(I) -> I*I end).
p54
    列表解析
    L = [1,2,3,4]
    [2*X || X < L] ==> [2,4,6,8]
p70
    catch 原语 捕捉erlang:error(a) 会有详细的信息
    包装math:sqrt(-1) 的错误消息
p71 通用风格
    f(X) 返回 {ok, Val}, {error, Why}
    1)
    case f(X) of
        {ok, Val} -> 
            do_some_thing_with(Val)
        {error, Why} ->
            %% ...
     2)
     {ok, Val} = f(X),
     do_some_thing_with(Val);  %% 如果返回错误 会因为匹配失败而抛出异常
     3)
     my_func(X) ->
        case ... of
            ... -> throw({thisError, ...})
            ... -> throw({someOtherError, ...})
     
     try my_func(X)
     catch
        throw:{thisError, X} -> ...
        throw:{someOtherError, X} -> ...
     end
     4) 捕获所有
     try Expr
     catch
        _:_ -> ... handle all exceptions
     end
     5) 忽略异常标签并按下面的方式写，，将不能捕获所有错误
     try Expr
     catch
        _ -> ... handle all 
     end
     6) 通常风格*****
     try foo(...) of
        Val -> ...
     catch
        exit: why -> ...
     end
p74
    tuple_to_list({1, 2, 3}).     == > [1,2,3]
    time().                       == > {20,0,3}
p75
    list_to_binary([Bin1, 1, [2,3,Bin2], 4|Bin3]).
    @spec split_binary(Bin, Pos)   -> {Bin1, Bin2}
    @spec term_to_binary(Term)  -> Bin      % 任意数据转换成二进制
    @spec binary_to_term(Bin)   -> Term     % 二进制数据还原
    @spec size(Bin) -> Int                  % 二进制数据长度